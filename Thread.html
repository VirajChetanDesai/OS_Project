<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Thread Deadlock Detection Visualization</title>
    <script type="text/javascript" src="https://unpkg.com/vis-network/standalone/umd/vis-network.min.js"></script>
    <style>
        body {
            font-family: 'Arial', sans-serif;
            background-color: #1c1c1c;
            color: white;
            padding: 20px;
            margin: 0;
        }
        #visualization {
            width: 100%;
            height: 400px;
            border: 1px solid lightgray;
            margin-top: 15px;
        }
        button {
            background-color: #0d6efd;
            color: white;
            border: none;
            padding: 10px 20px;
            margin: 10px;
            border-radius: 5px;
            cursor: pointer;
        }
        button:hover {
            background-color: #0b5ed7;
        }
        #status {
            color: #FFC107;
            margin-top: 10px;
        }
    </style>
</head>
<body>
    <h1>Thread Deadlock Detection Visualization</h1>
    <div id="visualization"></div>
    <button onclick="generateRandomScenario()">Generate Random Scenario</button>
    <button onclick="detectDeadlocks()">Detect Deadlock</button>
    <button onclick="resolveDeadlocks()">Resolve Deadlock</button>
    <div id="status"></div>
    
    <script>
        // Initialization for vis.js
        const nodes = new vis.DataSet();
        const edges = new vis.DataSet();
        const container = document.getElementById('visualization');
        const data = { nodes, edges };
        const options = {
            nodes: {
                shape: 'box',
                color: {
                    border: '#2B7CE9',
                    background: '#97C2FC',
                    highlight: {
                        border: '#2B7CE9',
                        background: '#D2E5FF'
                    }
                },
            },
            edges: {
                arrows: 'to'
            },
            physics: {
                enabled: false // Disable physics for a stable network
            },
            interaction: {
                zoomView: false, // Disables zooming
                dragView: false  // Disables dragging/panning
            }
        };
        const network = new vis.Network(container, data, options);

        // Thread and resource simulation setup
        const maxThreads = 4;
        const maxResources = 3;
        let threads = {};
        let resources = {};
        let deadlockChains = []; // Store detected deadlocks

        function initializeThreadsAndResources() {
            threads = {}; // Reset threads
            resources = {}; // Reset resources
            nodes.clear();
            edges.clear();
            for (let i = 0; i < maxThreads; i++) {
                const threadId = `Thread${i}`;
                threads[threadId] = { holding: [], waiting: null };
                nodes.add({ id: threadId, label: threadId, color: '#7BE141' });
            }
            for (let i = 0; i < maxResources; i++) {
                const resourceId = `Resource${i}`;
                resources[resourceId] = null;
                nodes.add({ id: resourceId, label: resourceId, color: '#FFC107' });
            }
            network.setData({ nodes, edges });
        }

        // Function to display status messages
        function displayStatus(message, isError = false) {
            const statusDiv = document.getElementById('status');
            statusDiv.textContent = message;
            statusDiv.style.color = isError ? '#FF5733' : '#FFC107'; // Red for errors, yellow for status
        }

        // Function to create a random deadlock scenario
        function generateRandomScenario() {
    // Clear existing data
    nodes.clear();
    edges.clear();
    threads = {};
    resources = {};

    // Reinitialize threads and resources
    for (let i = 0; i < maxThreads; i++) {
        const threadId = `Thread${i}`;
        threads[threadId] = { holding: [], waiting: null };
        nodes.add({ id: threadId, label: threadId, color: '#7BE141' });
    }
    for (let i = 0; i < maxResources; i++) {
        const resourceId = `Resource${i}`;
        resources[resourceId] = null;
        nodes.add({ id: resourceId, label: resourceId, color: '#FFC107' });
    }

    // Create a new random scenario
    for (let i = 0; i < maxThreads; i++) {
        const threadId = `Thread${i}`;
        let randomResourceIndex = Math.floor(Math.random() * maxResources);
        let resourceId = `Resource${randomResourceIndex}`;

        // Randomly decide if the thread will be waiting for or holding a resource
        if (Math.random() > 0.5) {
            threads[threadId].waiting = resourceId;
            edges.add({ from: threadId, to: resourceId });
        } else {
            threads[threadId].holding.push(resourceId);
            resources[resourceId] = threadId;
            edges.add({ from: resourceId, to: threadId });
        }
    }

    network.setData({ nodes, edges });
    displayStatus('Random scenario generated. Ready for deadlock detection.');
}

        // Detect deadlocks in the current state
        function detectDeadlocks() {
            deadlockChains.length = 0; // Clear previous deadlock chains
            let visited = {};
            let stack = [];

            function visit(threadId, chain = []) {
                if (visited[threadId]) {
                    if (stack.includes(threadId)) {
                        deadlockChains.push([...chain, threadId]);
                        return;
                    }
                    return;
                }
                visited[threadId] = true;
                stack.push(threadId);

                const waitingResource = threads[threadId].waiting;
                if (waitingResource) {
                    const ownerThread = resources[waitingResource];
                    if (ownerThread && ownerThread !== threadId) {
                        visit(ownerThread, [...chain, threadId]);
                    }
                }

                stack.pop();
            }

            Object.keys(threads).forEach(threadId => {
                if (!visited[threadId]) {
                    visit(threadId);
                }
            });

            if (deadlockChains.length > 0) {
                displayStatus('Deadlock detected!', true);
            } else {
                displayStatus('No deadlocks detected.');
            }
        }

        // Resolve deadlocks
        function resolveDeadlocks() {
            if (deadlockChains.length === 0) {
                displayStatus('No deadlock to resolve.', false);
                return;
            }

            deadlockChains.forEach(chain => {
                const threadToRollback = chain[0]; // Rollback the first thread in the deadlock chain
                threads[threadToRollback].holding.forEach(resourceId => {
                    resources[resourceId] = null;
                    nodes.update({ id: resourceId, color: '#FFC107' }); // Reset resource color
                });
                threads[threadToRollback].holding.length = 0; // Clear the holding array
                threads[threadToRollback].waiting = null; // Reset the waiting property
                nodes.update({ id: threadToRollback, color: '#7BE141' }); // Reset thread color
            });
            
            deadlockChains.length = 0; // Clear deadlock chains after resolution
            network.setData({ nodes, edges }); // Update the network graph
            displayStatus('Deadlock resolved.', false);
        }

        // Initialize the graph with a random scenario
        generateRandomScenario();
    </script>    
</body>
</html>
